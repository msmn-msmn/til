# ★Rubyで学んだ配列やハッシュについて
## 🔷 配列とは？
　配列は、Rubyにおけるあらゆる種類のオブジェクトを格納できるデータ構造です。<br>
　ここで言う「オブジェクト」とは、<br>
　Rubyで扱えるすべてのデータ型（数値、文字列、シンボル、配列、ハッシュ、オブジェクトなど）を指します。<br>
　たとえば以下のように書くことで、配列を表現できます。<br>
 ```
   [1, 2, 3]
 ```
<br>
<br>

## 🔷 ハッシュ（連想配列）とは？
　ハッシュは「連想配列」とも呼ばれ、キーと値のペアで構成されたデータ構造です。<br>
　任意の種類のオブジェクト（キー）から、別のオブジェクト（値）への**対応（マッピング）**を行うことができます。<br>
　例えば、次のように書きます。<br>
 ```
   { a => 1, b => 2, c => 3 }
 ```
　※ただし、ここで a、b、c は 変数として事前に定義されている必要があります。<br>
　　定義されていないとエラーになります（NameError）。<br>

<br>
　このように「キー => 値」のペアで構成されます。<br>
　ハッシュの生成は主にリテラル（ハッシュ式）で行われます。<br>
　以下のような書き方があります<br>
 
```
   { a => b }          # aはキー、bは値となる（基本形）
   { s: b }            # { :s => b } と同じ。シンボルキーの省略形
   { "a+" => b }       # キーに記号や空白を含めたいときの書き方（文字列キー）
   { :"a+" => b }      # 記号などを含むシンボルキーの書き方
```

## 🧩 各データ構造からの要素の取り出し方
### ✅ 配列の場合
　Array = [1, 2, 3]という配列があったとして<br>
```
    array = [1, 2, 3]

    p array[0] #=> 1
    p array[1] #=> 2
    p array[2] #=> 3
```
　というように要素が取り出せる。インデックス（番号）は 0から始まるので注意！<br>

### ✅ ハッシュの場合
　🟦 キーがシンボルのハッシュ<br>
```
    hash = { a: 1, b: 2, c: 3 }

    p hash[:a] #=> 1
    p hash[:b] #=> 2
    p hash[:c] #=> 3
```
　a: 1 という書き方は、実際には :a => 1 という意味になります。<br>
　したがって、アクセスするときも hash[:a] のようにシンボルで指定します。<br>

　🟨 キーが文字列のハッシュ<br>
```
    hash = { "a" => 1, "b" => 2, "c" => 3 }

    p hash["a"] #=> 1
    p hash["b"] #=> 2
    p hash["c"] #=> 3
```
　文字列キーの場合は、hash["a"] のように文字列でアクセスする必要があります。<br>
　シンボルと混同しやすいので注意が必要です。<br>

　🟥 キーが変数のハッシュ<br>
```
    a = :a
    b = :b
    c = :c

    hash = { a => 1, b => 2, c => 3 }

    p hash[a] #=> 1
    p hash[b] #=> 2
    p hash[c] #=> 3
```
　変数をキーとして使う場合は、事前に変数を定義しておく必要があります。<br>
　このように、シンボルを変数に入れておくことで、意味の明確化や再利用性を高めることができます。<br>
　たとえば：<br>
　・「これはステータスを表すキーだよ」と明示したいときは status_key = :status<br>
　・複数のハッシュで同じキーを使いたいときにも便利！<br>


 ## 配列・ハッシュを任意の形に整形するやり方
 　配列やハッシュを任意の形に整形するにはmapメソッドを使用します。<br>

 ### 　mapメソッドとは？
　　　mapメソッドは配列・ハッシュの各要素に対してブロックを評価した結果を全て含む配列を返します。<br>
  　　each文のように要素の数だけループを繰り返す。<br>
　　　eachメソッドの場合は返り値の配列・ハッシュは元の値のままですが、<br>
　　　mapメソッドの場合の返り値はブロックを引数とした処理式で評価した値が返ってきます。<br>
    <br>
 ### 　配列の場合
```
        test_data = [[1, "a"], [2, "b"], [3, "c"]]

        mapped_data = test_data.map{|num, str|
          [str, num]
        }

        p mapped_data  #=> [["a", 1], ["b", 2], ["c", 3]]
```
　　このようにブロックの中身を引数として処理式を評価した内容が全て一つの配列に格納されて帰ってくる。<br>
　　このコードを下記のように書き換えると<br>
 ```
        test_data = [[1, "a"], [2, "b"], [3, "c"]]

        mapped_data = test_data.map{|num, str|
          [str, num[0]]                        #<= numをnum[0]に変更
        }

        p mapped_data  #=> [["a", 1], ["b", 0], ["c", 1]]
```
　　という結果が返ってくる。<br>
