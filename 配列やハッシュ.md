# ★Rubyで学んだ配列やハッシュについて
## 🔷 配列とは？
　配列は、Rubyにおけるあらゆる種類のオブジェクトを格納できるデータ構造です。<br>
　ここで言う「オブジェクト」とは、<br>
　Rubyで扱えるすべてのデータ型（数値、文字列、シンボル、配列、ハッシュ、オブジェクトなど）を指します。<br>
　たとえば以下のように書くことで、配列を表現できます。<br>
 ```
   [1, 2, 3]
 ```
<br>
<br>

## 🔷 ハッシュ（連想配列）とは？
　ハッシュは「連想配列」とも呼ばれ、キーと値のペアで構成されたデータ構造です。<br>
　任意の種類のオブジェクト（キー）から、別のオブジェクト（値）への**対応（マッピング）**を行うことができます。<br>
　例えば、次のように書きます。<br>
 ```
   { a => 1, b => 2, c => 3 }
 ```
　※ただし、ここで a、b、c は 変数として事前に定義されている必要があります。<br>
　　定義されていないとエラーになります（NameError）。<br>

<br>
　このように「キー => 値」のペアで構成されます。<br>
　ハッシュの生成は主にリテラル（ハッシュ式）で行われます。<br>
　以下のような書き方があります<br>
 
```
   { a => b }          # aはキー、bは値となる（基本形）
   { s: b }            # { :s => b } と同じ。シンボルキーの省略形
   { "a+" => b }       # キーに記号や空白を含めたいときの書き方（文字列キー）
   { :"a+" => b }      # 記号などを含むシンボルキーの書き方
```

## 🧩 各データ構造からの要素の取り出し方
### ✅ 配列の場合
　Array = [1, 2, 3]という配列があったとして<br>
```
    array = [1, 2, 3]

    p array[0] #=> 1
    p array[1] #=> 2
    p array[2] #=> 3
```
　というように要素が取り出せる。インデックス（番号）は 0から始まるので注意！<br>

### ✅ ハッシュの場合
　🟦 キーがシンボルのハッシュ<br>
```
    hash = { a: 1, b: 2, c: 3 }

    p hash[:a] #=> 1
    p hash[:b] #=> 2
    p hash[:c] #=> 3
```
　a: 1 という書き方は、実際には :a => 1 という意味になります。<br>
　したがって、アクセスするときも hash[:a] のようにシンボルで指定します。<br>

　🟨 キーが文字列のハッシュ<br>
```
    hash = { "a" => 1, "b" => 2, "c" => 3 }

    p hash["a"] #=> 1
    p hash["b"] #=> 2
    p hash["c"] #=> 3
```
　文字列キーの場合は、hash["a"] のように文字列でアクセスする必要があります。<br>
　シンボルと混同しやすいので注意が必要です。<br>

　🟥 キーが変数のハッシュ<br>
```
    a = :a
    b = :b
    c = :c

    hash = { a => 1, b => 2, c => 3 }

    p hash[a] #=> 1
    p hash[b] #=> 2
    p hash[c] #=> 3
```
　変数をキーとして使う場合は、事前に変数を定義しておく必要があります。<br>
　このように、シンボルを変数に入れておくことで、意味の明確化や再利用性を高めることができます。<br>
　たとえば：<br>
　・「これはステータスを表すキーだよ」と明示したいときは status_key = :status<br>
　・複数のハッシュで同じキーを使いたいときにも便利！<br>


 ## 配列・ハッシュを任意の形に整形するやり方
 　配列やハッシュを任意の形に整形するにはmapメソッドを使用します。<br>

 ### 　mapメソッドとは？
　　　mapメソッドは配列・ハッシュの各要素に対してブロックを評価した結果を全て含む配列を返します。<br>
  　　each文のように要素の数だけループを繰り返す。<br>
　　　eachメソッドの場合は返り値の配列・ハッシュは元の値のままですが、<br>
　　　mapメソッドの場合の返り値はブロックを引数とした処理式で評価した値が返ってきます。<br>
    <br>
### 　配列の場合
```
        test_data = [[1, "a"], [2, "b"], [3, "c"]]

        mapped_data = test_data.map{|num, str|
          [str, num]
        }

        p mapped_data  #=> [["a", 1], ["b", 2], ["c", 3]]
```
　　このようにブロックの中身を引数として処理式を評価した内容が全て一つの配列に格納されて帰ってくる。<br>
　　このコードを下記のように書き換えると<br>
 ```
        test_data = [[1, "a"], [2, "b"], [3, "c"]]

        mapped_data = test_data.map{|num, str|
          [str, num[0]]                        #<= numをnum[0]に変更
        }

        p mapped_data  #=> [["a", 1], ["b", 0], ["c", 1]]
```
　　という結果が返ってくる。<br>
  <br>
　　なぜこうなるのかというと、整数型(Integer)であるnumに対してインデックスアクセス([]メソッド)をしているからです。<br>
　　整数型(Integer)に対して[]でアクセスするとビットアクセスになり、<br>
　　結果はインデックスで指定した桁の二進数のビットの値が返ってきます。<br>
  <br>
　　・整数値に対するインデックスアクセスの挙動<br>
　　　
   ```
　　　　　1[0] #=>1　1を二進数にすると0001よって1が返ってきます。

　　　　　2[0] #=>0　2を二進数にすると0010よって0が返ってきます。
　　　　　2[1] #=>1　2を二進数にすると0010よって1が返ってきます。

　　　　　3[0] #=>1　3を二進数にすると0011よって1が返ってきます。
```
　　　通常は配列で使う記法だけど、整数に使うと別の意味になるので注意！<br>

### 　ハッシュの場合
```
        test_data = { a: 1, b: 2, c: 3 }

        mapped_data = test_data.map{|key, val|
          [val, key]
        }

        p mapped_data  #=> [[1, :a], [2, :b], [3, :c]]
```
　　という結果が返ってくる。<br>
　　これを下記のように書き換えると<br>
```
test_data = { a: "1", b: "22", c: "333" }

        mapped_data = test_data.map{|key, val|
          {
            str: key,
            int: val,
            val_size: val.size
          }
        }

        p mapped_data  #=> [{:str=>:a, :int=>"1", :val_size=>1}, {:str=>:b, :int=>"22", :val_size=>2}, {:str=>:c, :int=>"333", :val_size=>3}]
```
　　という結果が返ってくる。<br>
　　mapメソッドの返り値は配列で帰ってくるため、整形した内容を全て含んだ１つの配列として<br>
　　mapped_dataに格納される。<br>
　　ブロック内の引数を<br>
```
           {
            str: key,
            int: val,
            val_size: val.size
          }
```
　　このように書くことでtest_data内のキーとバリューを任意に抽出して整形することができる。<br>
　　また、val_sizeのようにブロック引数にメソッドを使用した返り値を新たな要素として追加することが出来る。<br>
　　ハッシュ内のコンマ(,)は見落としやすいので注意！<br>
<br>
　　上記のコードでバリューの値が整数型の場合<br>
```
        test_data = { a: 1, b: 22, c: 333 }

        mapped_data = test_data.map{|key, val|
          {
            str: key,
            int: val,
            val_size: val.size
          }
        }

        p mapped_data  #=> [{:str=>:a, :int=>1, :val_size=>8}, {:str=>:b, :int=>22, :val_size=>8}, {:str=>:c, :int=>333, :val_size=>8}]
```
　　という結果が返ってくる。<br>
　　val_sizeが8で一律になっているのは、sizeメソッドが桁数のカウントには対応していないから。<br>
　　では何故、val_size=>8 になるかというと`整数型.size`で返ってくるのが<br>
　　対象の整数値を格納するのに必要なバイト数で返ってくるからです。<br>

　　1~333で一律で同じ値が返る理由は<br>
　　Rubyでは、小さな整数でも 内部的に「最小で8バイト（64ビット）」確保する仕様になってるからです。<br>
```
        1.size       # => 8
        333.size     # => 8
        1234567890.size # => 8
```
　　これが**Bignum**と呼ばれる更にデカい桁数の整数になるとこのバイト数も変化します。<br>
```
        (256**10 - 1).size       # => 16
        (2**64).size             # => 16 ← 64ビットを超えるから！
```



  | 型                                                 | 内容                              |
| ------------------------------------------------- | ------------------------------- |
| **Fixnum**（Ruby 2.3以前）または **Integer**（Ruby 2.4以降） | 通常の整数。\*\*64ビット（8バイト）\*\*の中に収まる |
| **Bignum**（巨大な数）                                  | 64ビットで収まらない大きな数。**追加でバイトを確保する** |

