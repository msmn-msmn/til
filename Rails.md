★アラート　削除前の確認ダイアログを表示させる方法
　link_to メソッドにdata: {confirm:""} を追加する。

　html.erb
　<%= link_to post_path(@post.id), method: :delete, data: {confirm: "削除しますか？"} %>

　上のようにlink_to にdata: {confirm: "表示したい文章"} を追加すると、削除ボタンを押した時に確認ダイアログが出てきます。


★リダイレクトの種類と意味
　Webアプリでは、あるページから別のページに移動（リダイレクト）することがよくあります。
　でも実は、「どう移動するか」には種類があって、ブラウザや検索エンジンはその違いをちゃんと見ています。

🔄 よく使われるリダイレクトの種類
　ステータスコード	/名前	/意味	/検索エンジンの反応
　301	/Moved Permanently（恒久的な移動）	/「このURLは永久にこっちに変わったよ」	/新しいURLをインデックスする（旧URLは無視）
　302	/Found（もともとTemporary Redirect）	/「今はたまたまこっちに移動するけど、そのうち戻るかもよ」	/旧URLのままインデックスすることが多い
　303	/See Other	/「POSTやDELETEとかした後は、とにかくGETでこのURL見て」	/フォーム送信後の正しい戻り先を伝える時に使う


★!を付けた場合の挙動に関して
　代表例) saveとsave!の違い

　save -> 保存できない場合はfalse

　save! -> 保存できない場合はActiveRecord::RecordInvalid発生

　感嘆詞を付けない場合(saveやcreate等)は、レコードの作成、保存に失敗した際、通常の場合はnilを返します。
　しかし、感嘆詞をつける場合(create!、save!)は、ActiveRecord::RecordNotFoundエラーを発生させることができます。
　つまり！をつけることにより、例外を発生させるか発生させないかの違いです。

★!の使い分け方
　saveメソッドの場合は保存の成功と失敗を true/false で返します。
　一方で、save!メソッドは保存を失敗した場合に例外を返します。
　つまり、save!を使えば例外をトリガーにしてロールバックなどの処理を行うことができるため、比較的使用頻度が高い。

★save! に ! をつけたら、ロールバックされるか？
　➤ 結論から言うと：
　🔸 save! 単体ではロールバックはされない！
　🔸 「トランザクション中で例外が出たとき」にだけロールバックされる！

🔍 どういうこと？
✴️ 例1：save! だけ使った場合

user = User.new(name: nil) # name は必須バリデーションあり
user.save! # バリデーションに引っかかるので保存できない　→ 例外 (ActiveRecord::RecordInvalid) が発生！
↑ これは 「例外が起きる」だけ
でも、トランザクション外だからロールバックは関係ない（元に戻すような前の処理がない）

✴️ 例2：トランザクション内で save! を使った場合

ActiveRecord::Base.transaction do
  post.save!
  comment.save!
  user.save! # ← ここでバリデーションエラー発生！
end
↑ これは 途中で user.save! が失敗して例外が出る
→ すると、それまでに保存された post や comment もロールバックされる！

🔥 まとめると
書き方/	例外が出る？	/ロールバックされる？
save	/出ない（true/false だけ返す）	/❌（明示的にやらない限り）
save!	/出る（例外が出る）	/❌（トランザクション外なら）
save! + トランザクション	/出る	/✅（このときだけ自動ロールバック）


★同期処理（Synchronous）とは
　◎定義
　　ある処理が終わるまで次の処理が始まらない方式のこと。
　　コードを上から順番に実行していき、前の処理が完了するまで次の処理に進まない。

　◎メリット
　　処理の流れがわかりやすい
　　コードが直列的に実行されるため、初心者でも読みやすく理解しやすい構造になりやすい。

　◎デバッグしやすい
　　順番に処理が進むので、バグが起きた場合に原因箇所を特定しやすい。

　◎デメリット
　　待ち時間が長くなる場合がある
　　時間のかかる処理（ネットワーク通信、ファイル操作など）があると、その処理が終わるまでプログラム全体が停止する。

　　ユーザー体験の低下
　　UI が固まっているように見える（フリーズしたように感じられる）など、操作性に悪影響を及ぼす可能性がある。


★非同期処理（Asynchronous）とは
　◎定義
　　ある処理の完了を待たずに、他の処理を進める方式のこと。
　　処理中に別の作業を並行して実行できるため、待ち時間を効率的に使うことができる。

　◎メリット
　　待ち時間の有効活用
　　重い計算やネットワーク通信をしている最中でも、別の処理を先に進められる。

　　アプリケーションの応答性が高い
　　UI が固まりづらく、スムーズに操作できるので、ユーザー体験が向上する。

　◎デメリット
　　プログラムが複雑になりがち
　　処理の終了タイミングやデータの受け渡しを管理する必要があり、コードが複雑化しやすい。

　　デバッグが難しい
　　タイミング依存の不具合が起きやすく、原因を突き止めるのに時間がかかることがある。



★Turbo Streamsのポイント
　リアルタイム更新が簡単にできる
　WebSocketやSSE経由で、DOMの一部だけを動的に更新可能。
　サーバーが送信する <turbo-stream> 要素を使って、DOMの操作を宣言的に記述。

　◎アクションとターゲット
　　action="append", prepend, replace, update, remove, before, after, refresh などのアクションが使える。
　　target や targets 属性で操作対象のDOM要素を指定。

　◎HTTPレスポンスにも対応
　　通常のフォーム送信後に text/vnd.turbo-stream.html を返すことで、全ページ更新せずに一部更新を可能に。
　　Railsの respond_to を使えば、HTMLとTurbo Streams両対応できる。

　◎テンプレートの再利用
　　サーバーサイドのパーシャルテンプレートをそのまま使って、クライアント側の更新にも使える。
　　フルページも、部分更新も、同じテンプレートで対応可能。

　◎段階的導入ができる
　　最初はTurboなしで実装して、徐々にTurbo Streamsを組み込むことで堅実に強化可能。

　❇️実際にやってみたい時Tips
　　Turboを使うにはHotwire（特にTurbo）をRailsにインストールする必要があります（gem 'turbo-rails'）。
　　Viewに <%= turbo_frame_tag ... %> を使ってフレーム範囲を決めたり、form_with model: ..., data: { 　　
  　turbo_stream: true } でストリーム対応にできます。

　　WebSocketと組み合わせたいなら、Action Cableとセットで使う。
